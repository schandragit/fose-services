%\subsection{Test Data Generation}

Enterprise applications are typically database-oriented, in that they make
queries over databases and the program flow depends on the data retrieved as a
result of a query.  To test whether the application satisfies its requirements,
sufficient amount of test data must be made available in the database. Consider,
for example, a banking application, in which one of the requirements to exercise
is that if a customer makes a certain fixed deposit, and the person is a senior
citizen and also holds a checking account in the bank, then an addition 0.25\%
is paid as interest. To test that this situation is handled correctly in the
application, there should exist a customer in the database such that his or her
age qualifies the person as senior citizen and the person also has a checking
account. Notice that typically, customer data and account data would be
maintained in separate database tables. Typically business requirements are
complex, and there need to be specific entries in multiple tables for a scenario
to work out.

When a client gives a testing contract, the client may expect the service
provider to exercise all the business rules, but may not give enough sample data
in the database to be able to exercise these rules, in part because of privacy
concerns. Anonymized test data, while it can overcome privacy issues, may in
fact be inadequate for good coverage~\cite{Grechanik:2010}, requiring a
balancing of privacy and utility goals~\cite{Taneja:2011}.  It then also becomes
the responsibility of the service provider to figure out the requisite and
adequate test data to be present in the pertinent tables.

Randomly generated test data cannot be expected to suffice for enterprise
applications with complex rules. Also, systematic test-generation approaches
based on program analysis (\eg \cite{Emmi:2007,Li:2010,Marcozzi:2012,Pan:2011})
cannot be expected to tackle enterprise applications, which use a mix of
multiple language and database technologies in their implementation. Moreover,
these techniques are directed toward attaining simple forms of code coverage,
such as statement or branch coverage, instead of complex business rules.

Black-box techniques for SQL-aware database generation (\eg \cite{Adir:2011,
delaRiva:2010, Khalek:2008}) and similar work done in the database community
(\eg \cite{Arasu:2011, Binnig:2007b}) may be relevant; however, as mentioned
before, enterprise applications are implemented with a mix of technologies.

Recent work on test generation for web applications targeted specifically toward
covering business rules~\cite{Thummalapenta:2013} is a step in the direction of
business-rule-driven test generation. However, the modeling of business rules in
that work---essentially as if-then conditions (which is similar to business-rule
notations in business rule management systems~\cite{drools,ilog})---may not be
expressive enough to guide automated generation of database records as
illustrated by our example. Other work on business rule
validation~\cite{Willmor:2006} focuses on augmenting existing tests with check
conditions, for a given specification of business rules in first-order logic, to
detect rule violations in a database.

Business rule management systems, \eg ILOG~\cite{ilog} and JBoss
Drools~\cite{drools}, provide features for specifying, maintaining, executing,
and monitoring business rules. In these systems, rules are externalized from the
application and can be evolved separately from the application code.  Although
such systems support rule execution and monitoring, the onus of developing
appropriate tests for covering the rules is on the user---these systems can only
monitor the rules triggered by user-provided tests.

We see a big opportunity for research contributions in this subarea. How to take
a specification of the application as testing criteria, and automatically
populate database that would enable various scenarios that fulfill the test
criteria to be exercised.
